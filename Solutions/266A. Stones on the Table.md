## Problem: 266A. Stones on the Table

### ðŸ“œ Description
Given a string `s` of length `n`, consisting of characters `'R'`, `'G'`, and `'B'`,  
each representing a stone color on a table.  
You must remove the **minimum number of stones** so that **no two adjacent stones** have the same color.

---

### ðŸ§© Constraints
- `1 <= n <= 50`
- `s.length == n`
- `s` contains only `'R'`, `'G'`, `'B'`

---

## ðŸ’¡ Idea
- Iterate through the string
- Count how many times `s[i] == s[i+1]`
- Each such match means one stone must be removed

---

## ðŸ§± Code (C++)

```cpp
#include <iostream>
using namespace std;

int main() {
    int n;
    cin >> n;
    string s;
    cin >> s;

    int count = 0;
    for (int i = 0; i < n - 1; i++) {
        if (s[i] == s[i + 1]) {
            count++;
        }
    }

    cout << count << endl;
    return 0;
}
```

## â±ï¸ Complexity

- Time: O(n)
- Space: O(1)

## ðŸ§  Key Tricks

- Simple adjacent comparison
- No need to modify the string
- Just count duplicates

---

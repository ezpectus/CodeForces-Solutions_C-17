# Codeforces 282A — Bit++ / Бит++

## Problem / Условие

You are given an integer variable `x = 0` and `n` operations.  
Each operation is one of: `++X`, `X++`, `--X`, `X--`.  
Each increases or decreases `x` by 1.  
Print the final value of `x` after all operations.

Дана переменная `x = 0` и `n` операций.  
Каждая операция — одна из: `++X`, `X++`, `--X`, `X--`.  
Каждая увеличивает или уменьшает `x` на 1.  
Вывести итоговое значение `x` после всех операций.

---

## Idea / Идея

Instead of parsing characters, we use `string::find()` and `string::npos` as filters.  
If `"++"` is found → increment.  
If `"--"` is found → decrement.

Вместо парсинга символов используем `string::find()` и `string::npos` как фильтр.  
Если найдено `"++"` → увеличиваем.  
Если найдено `"--"` → уменьшаем.

---

## Code (C++17)

```cpp
#include <iostream>
#include <string>
using namespace std;

int main() {
    int n;
    string s;
    cin >> n;

    int res = 0;
    for (int i = 0; i < n; i++) {
        cin >> s;
        if (s.find("++") != string::npos) res++;
        else if (s.find("--") != string::npos) res--;
    }
    cout << res << endl;
    return 0;
}
```

## Tests / Тесты

| Input / Ввод             | Output / Вывод |
|--------------------------|----------------|
| `1\n++X`                 | `1`            |
| `2\nX++\n--X`            | `0`            |
| `3\nX--\n--X\nX--`       | `-3`           |

## Conclusion / Вывод

Architecturally — this is a filter task, not a parsing one.  
Using `find()` and `npos` avoids manual character checks.  
Clean, fast, and scalable.

Архитектурно — задача на фильтрацию, не на парсинг.  
`find()` и `npos` избавляют от ручной проверки символов.  
Чисто, быстро, масштабируемо.

---
